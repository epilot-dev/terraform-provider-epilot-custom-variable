// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/epilot-dev/terraform-provider-epilot-product/internal/sdk/pkg/utils"
)

// PriceUpdateBillingDurationUnit - The billing period duration unit
type PriceUpdateBillingDurationUnit string

const (
	PriceUpdateBillingDurationUnitWeeks  PriceUpdateBillingDurationUnit = "weeks"
	PriceUpdateBillingDurationUnitMonths PriceUpdateBillingDurationUnit = "months"
	PriceUpdateBillingDurationUnitYears  PriceUpdateBillingDurationUnit = "years"
)

func (e PriceUpdateBillingDurationUnit) ToPointer() *PriceUpdateBillingDurationUnit {
	return &e
}

func (e *PriceUpdateBillingDurationUnit) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "weeks":
		fallthrough
	case "months":
		fallthrough
	case "years":
		*e = PriceUpdateBillingDurationUnit(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PriceUpdateBillingDurationUnit: %v", v)
	}
}

// PriceUpdateNoticeTimeUnit - The notice period duration unit
type PriceUpdateNoticeTimeUnit string

const (
	PriceUpdateNoticeTimeUnitWeeks  PriceUpdateNoticeTimeUnit = "weeks"
	PriceUpdateNoticeTimeUnitMonths PriceUpdateNoticeTimeUnit = "months"
	PriceUpdateNoticeTimeUnitYears  PriceUpdateNoticeTimeUnit = "years"
)

func (e PriceUpdateNoticeTimeUnit) ToPointer() *PriceUpdateNoticeTimeUnit {
	return &e
}

func (e *PriceUpdateNoticeTimeUnit) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "weeks":
		fallthrough
	case "months":
		fallthrough
	case "years":
		*e = PriceUpdateNoticeTimeUnit(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PriceUpdateNoticeTimeUnit: %v", v)
	}
}

// PriceUpdatePriceDisplayInJourneys - Defines the way the price amount is display in epilot journeys.
type PriceUpdatePriceDisplayInJourneys string

const (
	PriceUpdatePriceDisplayInJourneysShowPrice           PriceUpdatePriceDisplayInJourneys = "show_price"
	PriceUpdatePriceDisplayInJourneysShowAsStartingPrice PriceUpdatePriceDisplayInJourneys = "show_as_starting_price"
	PriceUpdatePriceDisplayInJourneysShowAsOnRequest     PriceUpdatePriceDisplayInJourneys = "show_as_on_request"
)

func (e PriceUpdatePriceDisplayInJourneys) ToPointer() *PriceUpdatePriceDisplayInJourneys {
	return &e
}

func (e *PriceUpdatePriceDisplayInJourneys) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "show_price":
		fallthrough
	case "show_as_starting_price":
		fallthrough
	case "show_as_on_request":
		*e = PriceUpdatePriceDisplayInJourneys(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PriceUpdatePriceDisplayInJourneys: %v", v)
	}
}

// PriceUpdatePricingModel - Describes how to compute the price per period. Either `per_unit`, `tiered_graduated` or `tiered_volume`.
// - `per_unit` indicates that the fixed amount (specified in unit_amount or unit_amount_decimal) will be charged per unit in quantity
// - `tiered_graduated` indicates that the unit pricing will be computed using tiers attribute. The customer pays the price per unit in every range their purchase rises through.
// - `tiered_volume` indicates that the unit pricing will be computed using tiers attribute. The customer pays the same unit price for all purchased units.
// - `tiered_flatfee` While similar to tiered_volume, tiered flat fee charges for the same price (flat) for the entire range instead using the unit price to multiply the quantity.
type PriceUpdatePricingModel string

const (
	PriceUpdatePricingModelPerUnit         PriceUpdatePricingModel = "per_unit"
	PriceUpdatePricingModelTieredVolume    PriceUpdatePricingModel = "tiered_volume"
	PriceUpdatePricingModelTieredGraduated PriceUpdatePricingModel = "tiered_graduated"
	PriceUpdatePricingModelTieredFlatfee   PriceUpdatePricingModel = "tiered_flatfee"
)

func (e PriceUpdatePricingModel) ToPointer() *PriceUpdatePricingModel {
	return &e
}

func (e *PriceUpdatePricingModel) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "per_unit":
		fallthrough
	case "tiered_volume":
		fallthrough
	case "tiered_graduated":
		fallthrough
	case "tiered_flatfee":
		*e = PriceUpdatePricingModel(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PriceUpdatePricingModel: %v", v)
	}
}

// PriceUpdateRenewalDurationUnit - The renewal period duration unit
type PriceUpdateRenewalDurationUnit string

const (
	PriceUpdateRenewalDurationUnitWeeks  PriceUpdateRenewalDurationUnit = "weeks"
	PriceUpdateRenewalDurationUnitMonths PriceUpdateRenewalDurationUnit = "months"
	PriceUpdateRenewalDurationUnitYears  PriceUpdateRenewalDurationUnit = "years"
)

func (e PriceUpdateRenewalDurationUnit) ToPointer() *PriceUpdateRenewalDurationUnit {
	return &e
}

func (e *PriceUpdateRenewalDurationUnit) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "weeks":
		fallthrough
	case "months":
		fallthrough
	case "years":
		*e = PriceUpdateRenewalDurationUnit(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PriceUpdateRenewalDurationUnit: %v", v)
	}
}

// PriceUpdateTerminationTimeUnit - The termination period duration unit
type PriceUpdateTerminationTimeUnit string

const (
	PriceUpdateTerminationTimeUnitWeeks  PriceUpdateTerminationTimeUnit = "weeks"
	PriceUpdateTerminationTimeUnitMonths PriceUpdateTerminationTimeUnit = "months"
	PriceUpdateTerminationTimeUnitYears  PriceUpdateTerminationTimeUnit = "years"
)

func (e PriceUpdateTerminationTimeUnit) ToPointer() *PriceUpdateTerminationTimeUnit {
	return &e
}

func (e *PriceUpdateTerminationTimeUnit) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "weeks":
		fallthrough
	case "months":
		fallthrough
	case "years":
		*e = PriceUpdateTerminationTimeUnit(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PriceUpdateTerminationTimeUnit: %v", v)
	}
}

// PriceUpdateType - One of `one_time` or `recurring` depending on whether the price is for a one-time purchase or a recurring (subscription) purchase.
type PriceUpdateType string

const (
	PriceUpdateTypeOneTime   PriceUpdateType = "one_time"
	PriceUpdateTypeRecurring PriceUpdateType = "recurring"
)

func (e PriceUpdateType) ToPointer() *PriceUpdateType {
	return &e
}

func (e *PriceUpdateType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "one_time":
		fallthrough
	case "recurring":
		*e = PriceUpdateType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PriceUpdateType: %v", v)
	}
}

// PriceUpdate1 - built-in units
type PriceUpdate1 string

const (
	PriceUpdate1Kw          PriceUpdate1 = "kw"
	PriceUpdate1Kwh         PriceUpdate1 = "kwh"
	PriceUpdate1M           PriceUpdate1 = "m"
	PriceUpdate1M2          PriceUpdate1 = "m2"
	PriceUpdate1L           PriceUpdate1 = "l"
	PriceUpdate1CubicMeter  PriceUpdate1 = "cubic-meter"
	PriceUpdate1CubicMeterH PriceUpdate1 = "cubic-meter-h"
	PriceUpdate1Ls          PriceUpdate1 = "ls"
	PriceUpdate1A           PriceUpdate1 = "a"
	PriceUpdate1Kva         PriceUpdate1 = "kva"
	PriceUpdate1W           PriceUpdate1 = "w"
	PriceUpdate1Wp          PriceUpdate1 = "wp"
	PriceUpdate1Kwp         PriceUpdate1 = "kwp"
)

func (e PriceUpdate1) ToPointer() *PriceUpdate1 {
	return &e
}

func (e *PriceUpdate1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "kw":
		fallthrough
	case "kwh":
		fallthrough
	case "m":
		fallthrough
	case "m2":
		fallthrough
	case "l":
		fallthrough
	case "cubic-meter":
		fallthrough
	case "cubic-meter-h":
		fallthrough
	case "ls":
		fallthrough
	case "a":
		fallthrough
	case "kva":
		fallthrough
	case "w":
		fallthrough
	case "wp":
		fallthrough
	case "kwp":
		*e = PriceUpdate1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PriceUpdate1: %v", v)
	}
}

type PriceUpdateUnitType string

const (
	PriceUpdateUnitTypePriceUpdate1 PriceUpdateUnitType = "PriceUpdate_1"
	PriceUpdateUnitTypeStr          PriceUpdateUnitType = "str"
)

type PriceUpdateUnit struct {
	PriceUpdate1 *PriceUpdate1
	Str          *string

	Type PriceUpdateUnitType
}

func CreatePriceUpdateUnitPriceUpdate1(priceUpdate1 PriceUpdate1) PriceUpdateUnit {
	typ := PriceUpdateUnitTypePriceUpdate1

	return PriceUpdateUnit{
		PriceUpdate1: &priceUpdate1,
		Type:         typ,
	}
}

func CreatePriceUpdateUnitStr(str string) PriceUpdateUnit {
	typ := PriceUpdateUnitTypeStr

	return PriceUpdateUnit{
		Str:  &str,
		Type: typ,
	}
}

func (u *PriceUpdateUnit) UnmarshalJSON(data []byte) error {

	priceUpdate1 := new(PriceUpdate1)
	if err := utils.UnmarshalJSON(data, &priceUpdate1, "", true, true); err == nil {
		u.PriceUpdate1 = priceUpdate1
		u.Type = PriceUpdateUnitTypePriceUpdate1
		return nil
	}

	str := new(string)
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = str
		u.Type = PriceUpdateUnitTypeStr
		return nil
	}

	return errors.New("could not unmarshal into supported union types")
}

func (u PriceUpdateUnit) MarshalJSON() ([]byte, error) {
	if u.PriceUpdate1 != nil {
		return utils.MarshalJSON(u.PriceUpdate1, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type: all fields are null")
}

type PriceUpdate struct {
	// Whether the price can be used for new purchases.
	Active *bool `json:"active,omitempty"`
	// The billing period duration
	BillingDurationAmount *float64 `json:"billing_duration_amount,omitempty"`
	// The billing period duration unit
	BillingDurationUnit *PriceUpdateBillingDurationUnit `json:"billing_duration_unit,omitempty"`
	// A brief description of the price.
	Description *string `json:"description,omitempty"`
	// The flag for prices that contain price components.
	IsCompositePrice *bool `json:"is_composite_price,omitempty"`
	// Specifies whether the price is considered `inclusive` of taxes or not.
	IsTaxInclusive *bool `default:"false" json:"is_tax_inclusive"`
	// A detailed description of the price. This is shown on the order document and order table. Multi-line supported.
	LongDescription *string `json:"long_description,omitempty"`
	// The notice period duration
	NoticeTimeAmount *float64 `json:"notice_time_amount,omitempty"`
	// The notice period duration unit
	NoticeTimeUnit *PriceUpdateNoticeTimeUnit `json:"notice_time_unit,omitempty"`
	// Defines the way the price amount is display in epilot journeys.
	PriceDisplayInJourneys *PriceUpdatePriceDisplayInJourneys `json:"price_display_in_journeys,omitempty"`
	// Describes how to compute the price per period. Either `per_unit`, `tiered_graduated` or `tiered_volume`.
	// - `per_unit` indicates that the fixed amount (specified in unit_amount or unit_amount_decimal) will be charged per unit in quantity
	// - `tiered_graduated` indicates that the unit pricing will be computed using tiers attribute. The customer pays the price per unit in every range their purchase rises through.
	// - `tiered_volume` indicates that the unit pricing will be computed using tiers attribute. The customer pays the same unit price for all purchased units.
	// - `tiered_flatfee` While similar to tiered_volume, tiered flat fee charges for the same price (flat) for the entire range instead using the unit price to multiply the quantity.
	//
	PricingModel *PriceUpdatePricingModel `default:"per_unit" json:"pricing_model"`
	// The renewal period duration
	RenewalDurationAmount *float64 `json:"renewal_duration_amount,omitempty"`
	// The renewal period duration unit
	RenewalDurationUnit *PriceUpdateRenewalDurationUnit `json:"renewal_duration_unit,omitempty"`
	Tax                 *BaseRelation                   `json:"tax,omitempty"`
	// The termination period duration
	TerminationTimeAmount *float64 `json:"termination_time_amount,omitempty"`
	// The termination period duration unit
	TerminationTimeUnit *PriceUpdateTerminationTimeUnit `json:"termination_time_unit,omitempty"`
	// Defines an array of tiers. Each tier has an upper bound, an unit amount and a flat fee.
	//
	Tiers []PriceTier `json:"tiers,omitempty"`
	// One of `one_time` or `recurring` depending on whether the price is for a one-time purchase or a recurring (subscription) purchase.
	Type *PriceUpdateType `default:"one_time" json:"type"`
	// The unit of measurement used for display purposes and possibly for calculations when the price is variable.
	Unit *PriceUpdateUnit `json:"unit,omitempty"`
	// The unit amount in cents to be charged, represented as a whole integer if possible.
	UnitAmount *float64 `json:"unit_amount,omitempty"`
	// Three-letter ISO currency code, in lowercase.
	UnitAmountCurrency *string `json:"unit_amount_currency,omitempty"`
	// The unit amount in cents to be charged, represented as a decimal string with at most 12 decimal places.
	UnitAmountDecimal *string `json:"unit_amount_decimal,omitempty"`
	// The flag for prices that can be influenced by external variables such as user input.
	VariablePrice *bool `default:"false" json:"variable_price"`
}

func (p PriceUpdate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *PriceUpdate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *PriceUpdate) GetActive() *bool {
	if o == nil {
		return nil
	}
	return o.Active
}

func (o *PriceUpdate) GetBillingDurationAmount() *float64 {
	if o == nil {
		return nil
	}
	return o.BillingDurationAmount
}

func (o *PriceUpdate) GetBillingDurationUnit() *PriceUpdateBillingDurationUnit {
	if o == nil {
		return nil
	}
	return o.BillingDurationUnit
}

func (o *PriceUpdate) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *PriceUpdate) GetIsCompositePrice() *bool {
	if o == nil {
		return nil
	}
	return o.IsCompositePrice
}

func (o *PriceUpdate) GetIsTaxInclusive() *bool {
	if o == nil {
		return nil
	}
	return o.IsTaxInclusive
}

func (o *PriceUpdate) GetLongDescription() *string {
	if o == nil {
		return nil
	}
	return o.LongDescription
}

func (o *PriceUpdate) GetNoticeTimeAmount() *float64 {
	if o == nil {
		return nil
	}
	return o.NoticeTimeAmount
}

func (o *PriceUpdate) GetNoticeTimeUnit() *PriceUpdateNoticeTimeUnit {
	if o == nil {
		return nil
	}
	return o.NoticeTimeUnit
}

func (o *PriceUpdate) GetPriceDisplayInJourneys() *PriceUpdatePriceDisplayInJourneys {
	if o == nil {
		return nil
	}
	return o.PriceDisplayInJourneys
}

func (o *PriceUpdate) GetPricingModel() *PriceUpdatePricingModel {
	if o == nil {
		return nil
	}
	return o.PricingModel
}

func (o *PriceUpdate) GetRenewalDurationAmount() *float64 {
	if o == nil {
		return nil
	}
	return o.RenewalDurationAmount
}

func (o *PriceUpdate) GetRenewalDurationUnit() *PriceUpdateRenewalDurationUnit {
	if o == nil {
		return nil
	}
	return o.RenewalDurationUnit
}

func (o *PriceUpdate) GetTax() *BaseRelation {
	if o == nil {
		return nil
	}
	return o.Tax
}

func (o *PriceUpdate) GetTerminationTimeAmount() *float64 {
	if o == nil {
		return nil
	}
	return o.TerminationTimeAmount
}

func (o *PriceUpdate) GetTerminationTimeUnit() *PriceUpdateTerminationTimeUnit {
	if o == nil {
		return nil
	}
	return o.TerminationTimeUnit
}

func (o *PriceUpdate) GetTiers() []PriceTier {
	if o == nil {
		return nil
	}
	return o.Tiers
}

func (o *PriceUpdate) GetType() *PriceUpdateType {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *PriceUpdate) GetUnit() *PriceUpdateUnit {
	if o == nil {
		return nil
	}
	return o.Unit
}

func (o *PriceUpdate) GetUnitAmount() *float64 {
	if o == nil {
		return nil
	}
	return o.UnitAmount
}

func (o *PriceUpdate) GetUnitAmountCurrency() *string {
	if o == nil {
		return nil
	}
	return o.UnitAmountCurrency
}

func (o *PriceUpdate) GetUnitAmountDecimal() *string {
	if o == nil {
		return nil
	}
	return o.UnitAmountDecimal
}

func (o *PriceUpdate) GetVariablePrice() *bool {
	if o == nil {
		return nil
	}
	return o.VariablePrice
}
